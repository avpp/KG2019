# Задача 5.

Основные объекты задачи должны быть вынесены в классы (модели).  
Для рисования примитивов можно использовать возможности graphics'а.  
Нельзя использовать готовые инструменты, например, возможности graphics'а по повороту, масштабированию или перемещению экранной системы координат.  
При разработке программы использовать подходы и архитектуру, рассмотренные на занятиях (классы и интерфейсы ScreenConverter, World{void update(dt); void draw(gr);}, Model, Vector*, Matrix* и др.).  
Было бы замечательно, если бы была возможность управлять скоростью анимации (задавать шаг по времени и количество таких шагов в единицу времени), приостанавливать анимацию, а также запускать с заданного начального момента времени.  
Также полезно иметь UI (в т.ч. управление мышью и клавиатурой), позволяющий управлять не только областью просмотра, но и параметрами анимируемой модели.  
Около каждой задачи указана ориентировочная сложность задачи + описаны разные уровни сложности. В целом, это число равно оценке при приемлемой реализации задачи.

* * *

Некоторые пояснения к задачам:

(1) Во всех задачах анимируемый объект должен описываться моделью, которая умеет вычислять своё новое состояние на основе предыдущего и умеет рисовать себя на заданном graphics'е (класс World).

(2) В программе следует использовать два таймера: первый отвечает за обновление состояния модели, а второй - за перерисовку.

* * *

Варианты заданий для задачи №5:

1.  Написать программу «Солнечная система». Можно воспринимать эту задачу как интерактивное пособие для школьников.  
    Пользователь должен иметь возможность добавлять и удалять планеты, задавать все необходимые параметры планет. Т.к. солнце очень большое по сравнению с планетами, то предлагается использовать при рисовании заведомо неправильные размеры объектов. Имеется несколько уровней сложности:
    * a.  (25) В [простом](https://spacegid.com/kompyuternaya-model-solnechnoy-sistemyi.html) [случае](https://spacegid.com/maket-solnechnoy-systemy.html) планеты движутся по эллиптическим орбитам, параметры которых задаются пользователем.
    * b.  (40) В сложном случае требуется описать физическую модель движения с учётом масс планет и других необходимых параметров.
    * c.  (+5) Если у планет рисуются текстуры, то можно сделать так, чтобы текстуры двигались, за счёт чего создавался бы эффект вращения. (текстуры должны, конечно же, подгружаться из файлов при создании планеты. Текстура может быть [развёрткой](https://st.weblancer.net/download/139839_935xp.jpg))
    * d.  (+5) Можно добавить возможность задавать естественные спутники планет.
2.  Написать программу перемещения изображения по экрану с отражением от стенок. Должно получиться что-то вроде [этого](https://www.youtube.com/watch?v=rAjfE9JHO_I).  
    Пользователь задаёт начальное положение и начальный вектор скорости.
    * a.  (25) Реализовать правильную и полноценную физику отражения.
    * b.  (+10) Позволить пользователю самостоятельно создавать любой объект (окружность, многоугольник, текст, загруженное из файла изображение). При этом потребуется применить порождающие паттерны. Сделать так, чтобы добавление нового вида фигуры заключалось просто в создании соответствующего класса.
    * c.  (35) Сделать то же самое, но в трёхмерном пространстве.
3.  Написать программу управления перемещением рисованного объекта клавиатурой.  
    Пользователь должен иметь возможность самостоятельно создавать любой объект (окружность, многоугольник, текст, загруженное из файла изображение). При этом потребуется применить порождающие паттерны. Сделать так, чтобы добавление нового вида фигуры в программу заключалось просто в создании соответствующего класса.  
    Ожидается, что при зажатии кнопки на клавиатуре, объект начинает двигаться, а при отпускании - прекращает
    * a.  (25) Простая реализация по описанию выше. Чтобы объект не потерять за границами экрана стоит сделать автоматическое плавное позиционированное. Кроме перемещения можно добавить ещё и поворот.
    * b.  (+10) Можно добавить физику ускорения и замедления. Таким образом, кнопка будет управлять не наличием скорости, а наличием внешнего воздействия. Опять-таки, у внешнего воздействия, наверняка, есть верхняя граница да и изменения могут происходить не линейно.
    * c.  (+15) Можно развить эту программу до небольшой игры, где игрок перемещается по большому прямоугольному миру. Сам мир генерируется динамически в процессе движения игрока и запоминается. При этом, конечно же, потребуется добавить логику проверки пересечения перемещаемого объекта с препятствиями и в зависимости от желаемого результата при пересечении, либо завершать игру, либо просто отскакивать. Цель такой игры - исследовать весь мир. В случае реализации игры ожидается, что при перемещении игрока за ним должна двигаться и камера, как это сделано в играх с видом сверху. Конечно же, камера начинает своё движение при приближению к краю экрана. Если у игрока может меняться скорость, то, вероятно, при увеличении скорости камера должна как бы отдаляться.
4.  Написать программу одновременного управления перемещением двух рисованных объектов клавиатурой.  
    Большая часть требований совпадает с требованиями к варианту 3.
    * a.  (25) Простая реализация по заданию.
    * b.  (+15) Сделать поддержку более двух объектов. Добавить возможность настраивать управление из пользовательского интерфейса.
    * c.  (+10) Можно развить до игры ping pong. Вероятно, очень интересной реализацией был бы вариант игры на четверых, где каждый отвечает за свою область. При реализации отражений от ракетки стоит учитывать направление движение самой ракетки, а также область, куда попадает мяч (в центре идеальное отражение, ближе к краям угол отражения должен меняться).
5.  Написать программу-мультфильм «Восход солнца в Японии»  
    Пользователь должен иметь расширенные возможности по управлению временем. Т.е. он должен иметь возможность останавливать анимация, проигрывать в разных направлениях с разной скоростью, задавать текущий момент времени. Кроме того, было бы замечательно, если бы пользователь мог задать параметры самого восхода (восход в разное время года отличается для строго заданного места)
    * a.  (25) Солнце проходит слева направо по эллиптической орбите (пользователь как бы смотрит на Юг или Юго-Восток в зимнее время).
    * b.  (+10) Добавлено изменение цвета солнца.
    * c.  (50) Пользователь смотрит на Восток и видит как из-за горизонта поднимается солнце. Всё начинается ещё ночью, небо тёмно синее, потом начинает светать. Цвет неба изменяется по градиенту, который необходимо самостоятельно уметь вычислять и рисовать попиксельно. При появлении солнца все цвета, опять-таки плавно изменяются на более красные. Не стоит забывать про оптический эффект уменьшения размера солнца в процессе восхода, а также про изменение его цвета.
6.  Написать программу-мультфильм «Едущий велосипед по асфальтной дороге». Пользователь смотрит сбоку.  
    Пользователь должен уметь управлять частотой педалирования, а также силой торможения.
    * a.  (25) Требуется создать эффект движения велосипеда по дороге. Для этого потребуется не только вращать колёса (будет видно по спицам), но и педали, а также ноги велосипедиста. Кроме того, чтобы создавался эффект движения, потребуется "сдвигать" дорогу и фон в сторону противоположенную направлению движения. На дороге нанесена пунктирная разметка ([см. ПДД горизонтальная дорожная разметка 1.5](http://autoprepod.ru/dorozhnaia-razmetka-pdd/1.5-razmetka-polos-dlia-dvizheniia-razmetka-dorozhnaia-pdd.html)). Конечно же, вращение колёс должно совпадать со скоростью движения (чтобы не было пробуксовок и скольжения).
    * b.  (+10) Можно добавить другие опорные объекты: деревья, [столбики](http://www.vashdom.ru/gost/50970-96/), периодически появляющиеся [отбойники](https://img.drive.ru/i/0/51cd8cce94a6560544000015.jpg), меняющаяся разметка и перекрёстки (вид всё тот же - сбоку от основной дороги), километровые столбы и др.
    * c.  (+5) Можно сделать велосипед скоростным, а также добавить эффекты неровной дороги и более реалистично смоделировать резкое торможение.
    * d.  (+10) Можно добавить управление частотой педалирования не с помощью ползунка или зажатой кнопки, а при помощи поочерёдного нажатия на две соседние клавиши. При этом будет создан эффект нажатия на каждую из педалей. Стоит предусмотреть обратный эффект, когда клавиши нажимают не в то время (педаль ещё не поднялась вверх, а её уже нажимают).
7.  Написать программу-мультфильм «Превращение стола в стул в комнате»  
    Пользователь задаёт параметры исходного и конечного объекта и запускает процесс превращения. В качестве одного из подходов можно использовать класс/интерфейс Furniture, который в общем виде описывал бы основные параметры и стола и стула (м.б. и других предметов). Далее, в программе создаются два экземпляра этого класса - начальный и конечный предметы мебели. В процессе анимации (при изменении текущего условного времени от 0 до 1 с каким-то малым шагом) вызывается функция, принимающая на вход начальное и конечное значение, а также текущее время t, и возвращающая новый экземпляр в этот момент времени, вычисленный на основе заданных входных параметров.
    * a.  (25) Двумерная модель, вид сбоку.
    * b.  (35) Двумерная модель, вид в перспективе комнаты.
    * c.  (45) Трёхмерная анимация.
    * d.  (+5) Сделать зависимость от времени не линейную, а любую через интерфейсе ITimeDependenceFunction и передавать конкретную реализацию этого интерфейса, выбранную пользователем, в функцию трансформации.-- Возможны другие способы решения этой задачи.
8.  Написать программу-мультфильм «Открывающаяся дверь замка»  
    Пользователь должен задать параметры двери, направление и время открывания. Также должна быть возможность посмотреть на дверь в любой момент времени открывания. Вероятно, это стоит сделать с помощью ползунка.  
    Не забывать про эффект увеличения ближней границы двери (при открывании).
    * a.  (25) Реализация на примере прямоугольной одностворчатой двери.
    * b.  (+5) Двустворчатая дверь.
    * c.  (+5) Непрямоугольная дверь.
    * d.  (+5) Сделать нелинейную зависимость угла открывания двери от времени. Можно воспользоваться интерфейсом ITimeDependenceFunction, конкретную реализацию которого пользователь выбирает в настройках анимации.
9.  Написать программу-мультфильм «Упругий теннисный мяч с деформацией»  
    Пользователь задаёт характеристики, начальное положение и направление движения мяча. Мяч начинает двигаться по экрану, отражаясь от стенок, при этом сжимаясь. Можно сделать движение с учётом силы тяжести, направленной вниз, а клики мышкой воспринимать как точку, из которой осуществляется дополнительное внешнее воздействие.
    * a.  (50) Разработать физическую модель упругого мяча.
10.  Написать программу, постепенно рисующую график функции и надписи  
    Пользователь выбирает желаемый график функции (экземпляр класса IFunction) и параметры анимации. Программа начинает рисовать график слева направо.  
    Для надписей указывается текст, положение и скорость отображения. После чего производится вывод текста как бы посимвольно (периодически появляется сразу по одному символу).
    * a.  (30) Простая анимация, описанная выше.
    * b.  (+10) Символы появляются непрерывно (т.е. в некоторые моменты времени можно наблюдать нарисованный, например на треть по ширине символ).
    * c.  (+10) Функции задаваться не y=f(x), а параметрически (x=f(t); y=g(t)).
    * d.  (50) Символы рисуются так, как будто их пишут рукой.
11.  Написать программу-мультфильм «[Колеса](https://www.youtube.com/watch?v=R0LkWHI1IYk) [паровоза](https://s00.yaplakal.com/pics/pics_original/0/3/7/5417730.jpg) едущие по рельсам». Вид [сбоку](https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Steam_locomotive_scheme_-_detailed.png/800px-Steam_locomotive_scheme_-_detailed.png).  
    Требуется анимировать привод паровоза. Пользователь должен задавать количество и радиус ведущих и ведомых колёс. Эффект движения достигается за счёт вращения колёс(видно по спицам), движения поршней и привода, а также движения фоновых или других опорных объектов. Конечно же, вращение колёс должно совпадать со скоростью движения (чтобы не было пробуксовок и скольжения).  
    Пользователь должен иметь возможность управлять скоростью движения.
    * a.  (30) Простая реализация.
    * b.  (+15) Реализовать физическую модель движения паровоза. Пользователь управляет воздействующей силой. Таким образом, в моменты [старта](https://youtu.be/e1PSE0KaTbQ) возникают [пробуксовки](https://youtu.be/umhuaS0CPtY), а при торможении - скольжение.
    * c.  (+5) Движение задним ходом.
12.  Написать программу «[Полет](https://www.youtube.com/watch?v=Au3YEDNy3Kw) [сквозь](https://cs.pikabu.ru/post_img/2014/01/07/0/1389041510_1068470236.gif) [звезды](https://www.youtube.com/watch?v=teFHZRpH5Pw)». В конце пути - Земля.  
    Положение каждой звезды можно хранить в полярных координатах. Тогда, при движении потребуется изменять лишь расстояние от центра и размеры. Как только звезда выходит за пределы экрана, её можно создать заново в центре со случайным положением. После нажатия пользователем определённой кнопки, в центре генерируется земля, которая в процессе полёта/приближения постепенно увеличивается.
    * a.  (25) Выполнение по описанию выше.
    * b.  (+10) Добавить возможность управления полётом.
    * c.  (+5) Текстуру Земли можно сделать вращающуюся.
13.  (45) Анимация огня (костра).  
    Есть несколько подходов к решению этой задачи. Можно посмотреть на [это](http://flash-animated.com/animatsiya-spetseffektov-ogon) или [это](http://limonmalina.com/Adobe-Photoshop/tema-20-5-gif-animacija-animirovannyj-ogon/images/gif-animacija-animirovannyj-ogon.gif).
14.  Анимация горящих свечек. Например, [такое](https://i.gifer.com/origin/de/deee96459a6937acb87b980447d212e4_w200.gif)
    * a.  (30) Просто анимация горения.
    * b.  (+15) Добавить влияние воздушных потоков, создаваемых с помощью мыши.
    * c.  (+5) Можно сделать задувание и зажигание свечей с помощью мыши.
15.  Анимация капель воды. Задаётся интенсивность дождя.
    * a.  (45) Как будто смотрим на лужу во время дождя [сверху](https://i.gifer.com/742S.gif)
    * b.  (45) Другая реализация - капли на [стекле](https://i.gifer.com/5lVo.gif)
16.  Анимация движения объекта по траектории.  
    Пользователь должен задать траекторию движения - выбирать одну из реализацией интерфейса IPath, который в общем виде описывает движение по траектории. Сделать несколько реализаций в виде параметрически заданных функций (движение по окружности и др.). Также полезно было бы сделать реализацию, которая бы генерировала траекторию по заданным пользователем точкам с заданной сглаженностью (в т.ч. с нулевой).
    * a.  (35) Простая реализация.
    * b.  (45) Пользователь задаёт скорость на каждом участке, опять-таки, с помощью функций. Или же вычисляется автоматически на основе траектории. Для последнего, возможно, потребуется указать дополнительную информацию о модели.
